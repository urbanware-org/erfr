
USAGE (erfr.py)

    Contents:

        1.  Definition
        2.  General stuff
          2.1  How to run Python scripts
          2.2  Overview of all command-line arguments
          2.3  Pseudo-random number generators
             2.3.1  urandom
             2.3.2  random
             2.3.3  Fortuna PRNG
             2.3.4  External generators
        3.  Basic encryption
          3.1  Encrypt a file
          3.2  Use an existing key to encrypt
          3.3  Use a Base64 key string to encrypt
          3.4  Decrypt the file again
        4.  Optional pseudo-obfuscation
          4.1  Encrypt and obfuscate files
          4.2  Decrypt the obfuscated files again
        5.  Optional byte rotation
          5.1  Rotate bytes on enryption
          5.2  Decrypt the file again
          5.3  User-defined rotation steps
          5.4  Rotation using the modulo operator
        6.  Optional byte reversion
        7.  Optional obfuscation via substitution-box
          7.1  Differences to previous Erfr versions
          7.2  Substitution-box feature
        8.  Task ID
          8.1  Purpose of the task ID
          8.2  Set a user-defined task ID
          8.3  Disable the task ID
        9.  Export encryption parameters

    1. Definition

        The main Erfr script to encrypt or decrypt a file using the one-time
        pad encryption method with optional features.

    2. General stuff

        2.1 How to run Python scripts

            All usage examples below show how to execute the Python scripts on
            the shell of a Unix-like system. If you do not know, how to run
            those scripts on your operating system, you may have a look at
            this page:

                http://www.urbanware.org/howto_python.html

        2.2 Overview of all command-line arguments

            Usually, each script requires command-line arguments to operate.
            So, to get an overview of all arguments available, simply run the
            script with the "--help" argument. For example:

                $ ./erfr.py --help

        2.3 Pseudo-random number generators

            Notice that every user decides which of these generators he wants
            to use or which is suitable for his purposes, whereby the user is
            responsible for his choice.

            For details as well as further information about the corresponding
            pseudo-random number generators and information in general, please
            read the technical documentations available on the web.

            2.3.1 urandom

                By default, the Erfr components use the built-in Python method
                "os.urandom()" to generate the random bytes for key files as
                well as obfuscation purposes, which uses sources provided by
                the operating system (such as "/dev/urandom" on Unix-like
                systems or "CryptGenRandom" on Windows).

                The main reason why Erfr uses this method by default is the
                fact, that it is available on various operating systems
                without any additional libraries.

                However, the quality of the random bytes that were generated
                by this method may vary on different operating systems,
                depending on the implementation of the pseudo-random number
                generator.

            2.3.2 random

                On Unix-like systems "/dev/random" is also available for
                generating random bytes, but it will block the encryption and
                key generation processes while waiting for more entropy.

                To use "/dev/random", append the "--dev-random" argument to
                the command line.

            2.3.3 Fortuna PRNG

                Since version 1.9.4, the Erfr project also supports the
                Fortuna pseudo-random number generator, which requires the
                PyCrypto library (see the "requirements.txt" file for
                details).

                To use Fortuna, append the "--fortuna" argument to the command
                line. By default, the generator is being seeded with pseudo-
                random bytes from "os.urandom()".

                On Unix-like systems it is also possible to seed the generator
                with pseudo-random bytes from "/dev/random" by additionally
                appending the command-line argument "--dev-random", but this
                will block the encryption and key generation processes while
                waiting for more entropy.

            2.3.4 External generators

                Furthermore, it is also possible to use key files generated by
                an external tool (or hardware) in case you do not want to use
                the random value generators provided or supported by Erfr for
                some reason.

    3. Basic encryption

        3.1 Encrypt a file

            Without optional command-line arguments, the input file will be
            encrypted using the default one-time pad encryption method and can
            also be decrypted with external tools that provide one-time pad
            decryption.

            For example, if you want to encrypt the text file "foobar.txt",
            write the key information into "foobar.key" and the encrypted
            output data into "foobar.enc", the command line would look like
            this:

                $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key \
                            -o foobar.enc

        3.2 Use an existing key to encrypt

            First of all, even though it is possible, it is absolutely NOT
            recommended to use the same key file or string multiple times to
            encrypt data, as this would be a security risk.

            The main purpose of this feature is that you can use a key file
            created by another tool in case you do not want to use the random
            value generators provided by Erfr for some reason.

            So, to use an existing key file, add the "--use-existing-key"
            argument to the command line. The Erfr script then assumes that
            the given key file is already existing and will not build a new
            one.

        3.3 Use a Base64 key string to encrypt

            It is also possible to use a Base64 key string to encrypt (and
            also decrypt) a file. The Erfr Key Generator component allows
            generating such a key string.

            To use this feature, add the "--base64" argument and give the
            Base64 key string instead of the key file path like this:

                $ ./erfr.py -a encrypt -i foobar.txt -k "owc+/WNTGJQ=" \
                            --base64 -o foobar.enc

        3.4 Decrypt the file again

            To decrypt the file again, the encrypted and the key file (in this
            example "foobar.enc" and "foobar.key") are both required. The data
            cannot be decrypted if either of them is missing.

            Now, to decrypt the encrypted file again and write the output data
            into the file "output.txt", type:

                $ ./erfr.py -a decrypt -i foobar.enc -k foobar.key \
                            -o output.txt

    4. Optional pseudo-obfuscation

        4.1 Encrypt and obfuscate files

            The key as well as the output file can be obfuscated by adding
            random bytes to them, so they cannot be assigned by their file
            size.

            As a matter of fact, after encrypting the input file, all related
            files have the same size. So, without obfuscation the key file can
            be assigned to the corresponding encrypted file by its size.

            When using the file obfuscation feature, the amount of random
            bytes for the encrypted and the key file should NOT be identical,
            because this would result in files with the same size again.

            Please also keep in mind that the obfuscation values used to
            encrypt are required to properly decrypt the encrypted data again.

            So, if you want to encrypt a text file called "foobar.txt", write
            the key information into "foobar.key", write the encrypted output
            data into "foobar.enc" and additionally obfuscate the key file
            (with 512 bytes), an additional argument is required:

                $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key \
                            -o foobar.enc --obfuscate-key 512

            To obfuscate the encrypted file instead (e. g. with 1024 bytes),
            the command line would look like this:

                $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key \
                            -o foobar.enc --obfuscate-enc 1024

            It is also possible to obfuscate both files. For example, to
            obfuscate the key (e. g. with 512 bytes) and the encrypted file
            (e. g. with 1024 bytes), type:

                $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key \
                            -o foobar.enc --obfuscate-key 512 \
                            --obfuscate-enc 1024

        4.2 Decrypt the obfuscated files again

            For example, if the key file was obfuscted with 512 bytes and the
            encrypted file with 1024 bytes (as in the example above), the
            command line to properly decrypt the data would look like this:

                $ ./erfr.py -a decrypt -i foobar.enc -k foobar.key \
                            -o output.txt --obfuscate-key 512 \
                            --obfuscate-enc 1024

            If the obfuscation values are missing, the files may also be
            decrypted, but the decrypted file will contain the additional
            random bytes used to obfuscate and depending on the file format,
            the file may be corrupted or even useless.

    5. Optional byte rotation

        5.1 Rotate bytes on encryption

            Another optional feature is the additional rotation of the input
            bytes.

            If you want to rotate the input bytes, you can add a byte range
            used for rotation. For example, for a range that starts with the
            value 2 and ends with value 8, the command line would look like
            this:

                $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key \
                            -o foobar.enc --rotate-min 2 --rotate-max 8 \
                            --rotate-step 1

            Please also keep in mind that the range values used to encrypt are
            required to properly decrypt the encrypted data again (just like
            the obfuscation values). The length of the given range must at
            least be 4.

            In this example, the roatation would modify the input bytes as
            follows:

                +------+---------+-------------+---------+
                | Byte | Ordinal | Range value | Result  |
                +------+---------+-------------+---------+
                |    1 |     120 |           2 |     122 |
                +------+---------+-------------+---------+
                |    2 |      96 |           3 |      99 |
                +------+---------+-------------+---------+
                |    3 |      67 |           4 |      71 |
                +------+---------+-------------+---------+
                |    4 |     234 |           5 |     239 |
                +------+---------+-------------+---------+
                |    5 |       2 |           6 |       8 |
                +------+---------+-------------+---------+
                |    6 |     141 |           7 |     148 |
                +------+---------+-------------+---------+
                |    7 |      93 |           8 |     101 |  (maximum value)
                +------+---------+-------------+---------+
                |    8 |      37 |           2 |      39 |  (reset range)
                +------+---------+-------------+---------+
                |    9 |     210 |           3 |     213 |
                +------+---------+-------------+---------+
                |   10 |      60 |           4 |      64 |
                +------+---------+-------------+---------+
                |  ... |     ... |         ... |     ... |  (and so on)
                +------+---------+-------------+---------+

            The step value can also be negative, which leads to decreasing
            byte range values.

            So, in case the range step value is postitive, the range value
            will be basically reset to the range minimum if it is greater than
            or equal to the range maximum.

            Therefore, if the step value is negative, the range value will be
            reset to the range maximum if it is less than or equal to the
            range minimum.

        5.2 Decrypt the file again

            The command-line arguments of are identical with those from the
            encryption process, with the simple difference, that the action
            has to be "decrypt" instead of "encrypt":

                $ ./erfr.py -a decrypt -i foobar.txt -k foobar.key \
                            -o foobar.enc --rotate-min 2 --rotate-max 8 \
                            --rotate-step 1

            If any wrong byte range value is given, the decrypted file will be
            corrupted, and as such, useless. This is related to all optional
            rotation arguments.

        5.3 User-defined rotation steps

            You can also change the rotation step value. Instead of simply
            adding the value of 1 to the current rotation value, you can pick
            a user-defined one, e. g. a value of 3, see below.

                $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key \
                            -o foobar.enc --rotate-min 2 --rotate-max 8 \
                            --rotate-step 3

            In this example, the rotation would modify the input bytes as
            follows:

                +------+---------+-------------+---------+
                | Byte | Ordinal | Range value | Result  |
                +------+---------+-------------+---------+
                |    1 |     120 |           2 |     122 |
                +------+---------+-------------+---------+
                |    2 |      96 |           5 |     111 |
                +------+---------+-------------+---------+
                |    3 |      67 |           8 |      75 |  (maximum value)
                +------+---------+-------------+---------+
                |    4 |     234 |           2 |     226 |  (reset range)
                +------+---------+-------------+---------+
                |    5 |       2 |           5 |       7 |
                +------+---------+-------------+---------+
                |    6 |     141 |           8 |     149 |  (maximum value)
                +------+---------+-------------+---------+
                |    7 |      93 |           2 |      95 |  (reset range)
                +------+---------+-------------+---------+
                |    8 |      37 |           5 |      42 |
                +------+---------+-------------+---------+
                |  ... |     ... |         ... |     ... |  (and so on)
                +------+---------+-------------+---------+

            The step value can also be negative, which leads to decreasing
            byte range values.

        5.4 Rotation using the modulo operator

            The byte rotation feature also allows using the modulo operator.

                $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key \
                            -o foobar.enc --rotate-min 2 --rotate-max 8 \
                            --rotate-step 3 --rotate-mod

            First, have a look at this table containing some sample data.

                +------+---------+-------------+---------+
                | Byte | Ordinal | Range value | Result  |
                +------+---------+-------------+---------+
                |    1 |     120 |           2 |     122 |
                +------+---------+-------------+---------+
                |    2 |      96 |           5 |     111 |
                +------+---------+-------------+---------+
                |    3 |      67 |           8 |      75 |  (maximum value)
                +------+---------+-------------+---------+
                |    4 |     234 |           4 |     238 |  (reset range)
                +------+---------+-------------+---------+
                |    5 |       2 |           7 |       9 |  (maximum value)
                +------+---------+-------------+---------+
                |    6 |     141 |           3 |     144 |  (reset range)
                +------+---------+-------------+---------+
                |    7 |      93 |           6 |      99 |  (maximum value)
                +------+---------+-------------+---------+
                |    8 |      37 |           2 |      39 |  (reset range)
                +------+---------+-------------+---------+
                |  ... |     ... |         ... |     ... |  (and so on)
                +------+---------+-------------+---------+

            In this example, the range value at the third byte reaches the
            maximum value. When adding another step to it

                8 + 3 = 11

            the new value of 11 exceeds the range maximum of 8 and needs to
            be reset. Before, the count of numbers inside the given range has
            been determined

                2, 3, 4, 5, 6, 7, 8;    (7 numbers)

            which is necessary for calculating the range value:

                Minimum range value:                        2
                Count of numbers in range:                  7
                Current range value:                       11

                New range value:   ((11 - 2) MOD 7) + 2 =   4

            So, the new range value for the fourth byte is 4. At the fifth
            byte there is a range value of 7. Adding another step also exceeds
            the maximum there

                7 + 3 = 10

            which leads to a new range value of 3

                ((10 - 2) MOD 7) + 2 = 3

            for the sixth byte.

            The step value can also be negative, which leads to decreasing
            byte range values.

    6. Optional byte reversion

        This feature requires a value for the user-defined range used to
        reverse the input bytes while encrypting a file.

        Please also keep in mind that the rotation value used to encrypt is
        required to properly decrypt the encrypted data again.

        So, if you want to encrypt a file and reverse a block of four bytes
        each, you need to add the "--reverse-bytes" argument followed by the
        value, for example:

            $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key -o foobar.enc \
                        --reverse-bytes 4

        With that value, the first bytes of the encrypted file would look like
        this:

            Before reversion:     After reversion:

            +------+---------+    +------+---------+
            | Byte | Ordinal |    | Byte | Ordinal |
            +------+---------+    +------+---------+
            |    1 |     120 |    |    1 |     234 |  (was byte 4 before)
            +------+---------+    +------+---------+
            |    2 |      96 |    |    2 |      67 |  (was byte 3 before)
            +------+---------+    +------+---------+
            |    3 |      67 |    |    3 |      96 |  (was byte 2 before)
            +------+---------+    +------+---------+
            |    4 |     234 |    |    4 |     120 |  (was byte 1 before)
            +------+---------+    +------+---------+
            |    5 |       2 |    |    5 |      37 |  (was byte 8 before)
            +------+---------+    +------+---------+
            |    6 |     141 |    |    6 |      93 |  (was byte 7 before)
            +------+---------+    +------+---------+
            |    7 |      93 |    |    7 |     141 |  (was byte 6 before)
            +------+---------+    +------+---------+
            |    8 |      37 |    |    8 |       2 |  (was byte 5 before)
            +------+---------+    +------+---------+
            |  ... |     ... |    |  ... |     ... |  (and so on)
            +------+---------+    +------+---------+

        The rotation value must not be negative and also not be less than 2.

    7. Optional obfuscation via substitution-box

        Another obfuscation method is applying a substition-box (also known as
        S-box) to the input bytes during the encryption process.

        7.1 Differences to previous Erfr versions

            With Erfr 4.3.0, the term "subbox" was replaced by "S-box". Due to
            this, the previously provided "--subbox" command-line argument has
            been replaced by "--use-sbox" and its short form "-s".

            Therefore, the old "--subbox" argument provided by Erfr 4.2.2 and
            below does not work anymore.

        7.2 Substitution-box feature

            The main Erfr component takes advantage of the Rijndael S-box. For
            details see the corresponding Wikipedia page about AES (Advanced
            Encryption Standard) encryption:

                https://en.wikipedia.org/wiki/Advanced_Encryption_Standard

            The difference to the obfuscation mentioned in section 4 is that
            this method obfuscates the actual input bytes instead of adding
            some random bytes to the file for pseudo-obfuscation purposes.

            To use the substitution-box feature, simply add the "-s" command-
            line argument, for example:

               $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key \
                           -o foobar.enc -s

    8. Task ID

        8.1 Purpose of the task ID

            When starting Erfr encryption, decryption, key generation or file
            obfuscation processes, the script returns a task ID and creates a
            temporary Base64 encoded task file for that ID which contains some
            information about the corresponding Erfr process.

            Some Erfr components use the task files to check if any given file
            is already in use by another Erfr process to avoid multiple Erfr
            processes accessing the same files at the same time.

            The task ID can also be used to monitor the the status of those
            processes (using the Erfr Monitor component).

            The temporary files of each Erfr process will be automatically
            deleted when the corresponding process has either been completed
            or cancelled.

        8.2 Set a user-defined task ID

            It is also possible to use a user-defined task ID for an Erfr
            process, e. g. for scripting purposes. Please keep in mind that
            the the same task ID cannot be used by multiple processes at the
            same time. For example, to start an encryption process with ID 8:

                $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key \
                            -o foobar.enc --task-id 8

        8.3 Disable the task ID

            The task ID can be disabled, but this will also disable all the
            features mentioned in section 8.1 above. To disable the task ID
            for the current process you can use the "--no-task-id" argument
            like this:

                $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key \
                            -o foobar.enc --no-task-id

            The old-fashioned and deprecated way is starting the process with
            a zero task ID:

                $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key \
                            -o foobar.enc --task-id 0

    9. Export encryption parameters

        Since Erfr version 4.3.0, it is possible to export all the encryption
        parameters (encryption related information you give by command-line
        arguments) into a INI-like file.

        This file can later be processed by the Erfr Executor component. This
        saves the labour of typing the same command multiple times with all
        the information required.

        The Erfr Executor script only expects two arguments:

            1. The parameter file containing all the relevant information.
            2. The action to perform (either encrypt or decrypt).

        Now, to export the parameters of the following command

            $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key \
                        -o foobar.enc --rotate-min 2 --rotate-max 8 \
                        --rotate-step 3 --rotate-mod

        add the "-e" argument followed by the name of a file where to export
        the parameters into, e. g. "foobar.par" (the suffix is arbitrary):

            $ ./erfr.py -a encrypt -i foobar.txt -k foobar.key \
                        -o foobar.enc --rotate-min 2 --rotate-max 8 \
                        --rotate-step 3 --rotate-mod -e foobar.par

        In this example, exported parameter file then contains the following
        information:

            [Erfr]
            version = 4.3.0

            [Task]
            task_id = 1

            [Files]
            input_file = /tmp/foobar.txt
            key_file = /tmp/foobar.key
            output_file = /tmp/foobar.enc

            [Options]
            buffer_size = 4096
            use_existing_key = 0
            overwrite = 0

            [Obfuscation]
            obfuscate_enc = 0
            obfuscate_key = 0

            [PRNG]
            fortuna = 0
            dev_random = 0

            [Rotation]
            rotate_min = 2
            rotate_max = 8
            rotate_step = 3
            rotate_mod = 1

            [Reversion]
            reverse_bytes = 0

            [S-box]
            sbox = 0

        In case you also give the "--overwrite" command-line argument, it is
        related to the input, key and output file (as expected) and also to
        the parameter file. So, if the export file already exists it will also
        be overwritten.

        Further information how to use those parameter files can be found
        inside the documentation for the Erfr Executor component.

